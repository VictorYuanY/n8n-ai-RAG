# Knowledge Base: Querying Enterprise Sales & Order Data (Databricks SQL)

**Version:** 1.8
**Last Updated:** 2025-07-29

## 1. Objective

This document guides users on executing read-only SQL queries against the enterprise data warehouse (Databricks instance) to retrieve business metrics. It focuses on:

*   Historical Orders/Shipments (Order on Hand - OOH, Actuals)
*   Budget/Forecast Data
*   Calculating derived metrics like Fill Rates.

Primary tables involved are `fna.fna_bronze.vw_gob_spencerorderbook` (historical) and `lft.bronze.dds_frwshp_jedox` (budget/forecast).

## 2. Standard Business Conventions & Terminology

These conventions **MUST** be followed in all business interactions:

### 2.1. OOH (Order on Hand) Definition

*   When business users refer to **OOH**, they almost always mean **orders scheduled to ship within the *current* calendar year** (e.g., 2025 as of the last update date), even if those orders were placed in a prior year or are part of snapshots containing next-year data.
*   **Implementation:** Filter queries accordingly, typically using `SHIP_YEAR = ?current_year?` (e.g., `SHIP_YEAR = 2025`) on the `vw_gob_spencerorderbook` table for standard OOH analysis.

### 2.2. Common Terminology/Aliases

*   **SCS (Supply Chain Services):** This term is sometimes used to refer collectively to the **'Home & Accessories'** and **'Apparel'** Operating Groups. Be aware of this alias when interpreting requests or filtering data. (See Appendix 8 for breakdown dimensions related to these OGs).

### 2.3. Notes on formatting
*   **Structure:** Use prose for context, bullet points for details.
*   **Monetary Values:**
    *   Millions: `USD #,##0.0m` (e.g., USD 1,234.5m)
    *   Thousands: `USD #,##0.0k` (e.g., USD 1,234.5k)
*   **Percentages:** `0.0%` (e.g., 25.7%).
*   **Negative Numbers:** Use descriptive words for clarity:
    *   `Loss of USD 1.0m` (instead of `- USD 1.0m Profit`)
    *   `Decrease of 5.0%` or `Decline of 5.0%` (instead of `- 5.0% Change`)


## 3. Key Data Sources (Tables)

### 3.1. Historical Orders/Shipments

*   **Table:** `fna.fna_bronze.vw_gob_spencerorderbook`
*   **Content:** Primary source for historical order book (OOH) and actuals/shipped data. Contains weekly snapshots of the order book state.
*   **Key Use:** Analyzing OOH trends, shipped values, historical comparisons.
*   **Important Considerations:** Subject to aggregation best practices (Section 6.6) and potential data retrieval limitations (Section 7.6).

### 3.2. Budget/Forecast Data

*   **Table:** `lft.bronze.dds_frwshp_jedox`
*   **Content:** Contains Budget or Forecast data (e.g., Net Sales targets). Typically aggregated at a higher level (e.g., yearly, monthly) than the weekly snapshot table.
*   **Key Use:** Providing the denominator for Fill Rate calculations, comparing OOH/Actuals against targets.

## 4. Key Data Elements (Columns)

### 4.1. Common Dimensions (for Filtering/Grouping)
*   **`SHIP_YEAR`**: Year the order is scheduled to ship or shipped (in `vw_gob_spencerorderbook`). Crucial for filtering OOH for a specific year (Section 2.1, 5.5).
*   **`REPORT_OPERATING_GROUP_DESC_UPDATED`**: Business unit description (e.g., 'Home And Accessories', 'Apparel').
    *   *Note:* 'Home And Accessories' and 'Apparel' are sometimes collectively referred to as 'Supply Chain Services (SCS)'. See Appendix 8 for known dimensions within these groups.
*   **`REPORT_OPERATING_GROUP_CODE_UPDATED`**: Code for the operating group (often used in standard exclusions, see Section 5.1).
*   **`REPORT_DIVISION_DESC`**: Division description within an Operating Group (e.g., 'AHA DIVISION'). See Appendix 8 for applicability.
*   **`REPORT_CORPORATE_CUSTOMER_NAME`**: Name of the customer account (e.g., 'ACTION SERVICE & DISTRIBUTIE B.V.').
    *   *Note:* High cardinality. Requires SQL Aggregation (Section 6.6). Subject to potential data retrieval limits (Section 7.6). See Appendix 8 for specific warnings and handling guidance (Section 6.7).

*   **`YEAR`**: Year in the Jedox table (`dds_frwshp_jedox`). Corresponds to `SHIP_YEAR`.
*   **`WEEK_NO`**: The snapshot week number (1-53, or special values like 99 for latest) in `vw_gob_spencerorderbook`. Identifies the specific weekly snapshot. See Section 5.4 regarding filtering.
*   **`SCENARIO`**: Type of data in `dds_frwshp_jedox` (e.g., 'Budget', 'Actual'). Used in Fill Rate calculations (Section 6.2).
*   **`SOURCE`**: Data source system identifier (used in standard exclusions, Section 5.1).

### 4.2. Common Metrics (for Calculation)

*   **`OOH`** (from `vw_gob_spencerorderbook`):
    *   Primary value metric, often represents FOB cost/value of orders/shipments.
    *   Use `SUM()` with `GROUP BY` in SQL for aggregation (**Mandatory** - See Section 6.6).
    *   Use high-precision types for aggregation (e.g., `CAST(SUM(OOH) AS DECIMAL(38, 10))`) in SQL.
*   **`NET_SALES`** (from `dds_frwshp_jedox`):
    *   Primary value metric for Budget/Forecast/Actuals.
    *   Use `SUM()` with `GROUP BY` in SQL for aggregation.

## 5. Standard Query Practices & Filters

Apply these filters to `vw_gob_spencerorderbook` queries unless explicitly asked to do otherwise. Adapt for `dds_frwshp_jedox` based on available columns.

### 5.1. Snapshot Week Filter

*   Target a specific snapshot week:
    ```sql
    -- In WHERE clause
    WEEK_NO = ?target_week? -- e.g., WEEK_NO = 15
    ```
*   Exclude week 99 unless specifically needed (it often represents a non-standard latest view):
    ```sql
    -- In WHERE clause (if querying across weeks)
    WEEK_NO < 99
    ```
*   if user say current week, that means current ISO week number. For example, 2025/7/23 is ISO Week Number of 30. 
    ```sql
    -- In WHERE clause 
    WEEK_NO = weekofyear(current_date())
    ```

### 5.2. Ship Year Filter

*   Focus analysis on a specific shipment year (essential for OOH, YoY, Fill Rate):
    ```sql
    -- In WHERE clause
    SHIP_YEAR = ?target_ship_year? -- e.g., SHIP_YEAR = 2025
    ```


## 6. Common Query Patterns & Calculations

This section outlines common analysis types and calculations. **Always apply Aggregation Best Practices (Section 6.6) and be aware of potential Data Retrieval Limits (Section 7.6) when querying `vw_gob_spencerorderbook`.**

### 6.1. Determining the Latest Snapshot Year and Week (Single Query Method)

*Purpose: Find the most recent snapshot year and the corresponding latest week number (excluding Week 99) available in the `vw_gob_spencerorderbook` table using a single, efficient query. This is often needed to establish the 'current' point-in-time for OOH analysis.*

**SQL Query:**
``` sql
SELECT
    CAST(SUBSTR((SHIP_YEAR), 1, 4) AS INT) AS latest_year,
    WEEK_NO AS latest_week
FROM fna.fna_bronze.vw_gob_spencerorderbook
WHERE
    WEEK_NO < 99
ORDER BY
    latest_year DESC,
    latest_week DESC
LIMIT 1;
```

**Explanation:**

*   This query filters exclude the non-standard `WEEK_NO = 99`.
*   Crucially, it orders the results first by ship year in descending order (`latest_year DESC`) and then by week number in descending order (`latest_week DESC`).
*   `LIMIT 1` ensures that only the very top row after ordering is returned, which corresponds to the latest week within the latest year meeting the filter criteria.
*   The result will be a single row containing the `latest_year` and `latest_week`.

**Note:** This single-query approach replaces any previous multi-step methods for improved efficiency and simplicity when finding the latest snapshot information.

### 6.2. Calculating Fill Rates (OOH vs. Budget/Actual)

Measures how much of a target (Budget/Actual `NET_SALES`) is covered by open OOH (`OOH`) as of a specific snapshot week.

#### 6.2.1. Concept

`Fill Rate % = (Sum of OOH OOH for Period / Sum of Target NET_SALES for Same Period) * 100`

#### 6.2.2. Data Sources & Matching

*   **Numerator (OOH):** `fna.fna_bronze.vw_gob_spencerorderbook`
    *   Filter by `WEEK_NO` (snapshot point-in-time), `SHIP_YEAR` (target period year).
    *   Apply standard filters (Section 5), `REPORT_TYPE` .
    *   **Use SQL aggregation `SUM(OOH)` (Section 6.6).**
*   **Denominator (Target):** `lft.bronze.dds_frwshp_jedox`
    *   Filter by `YEAR` (matching the OOH `SHIP_YEAR`), `SCENARIO` ('Budget' or 'Actual').
    *   *Note: Jedox data usually represents full-year values.*
    *   Apply standard exclusions (Section 5.1) if applicable based on `REPORT_OPERATING_GROUP_CODE_UPDATED` or `REPORT_OPERATING_GROUP_DESC_UPDATED` if available in Jedox.
*   **Matching Dimensions:** Ensure both queries are filtered or grouped by the *same* dimensions (e.g., `REPORT_OPERATING_GROUP_DESC_UPDATED`, `DIVISION_DESC`) for detailed fill rates.

#### 6.2.3. Example: Calculate 2025 OOH Fill Rate vs. 2025 Budget for 'Home And Accessories' as of Week 15 (Snapshot in 2025)

*Requires two queries; calculation done outside SQL.*

1.  **Get 2025 OOH Value (Numerator):**
    ```sql
    SELECT CAST(SUM(OOH) AS DECIMAL(38, 10)) AS OOH_Value_Base_CY
    FROM fna.fna_bronze.vw_gob_spencerorderbook
    WHERE REPORT_OPERATING_GROUP_DESC_UPDATED = 'Home And Accessories'
      AND WEEK_NO = 15 -- Specific snapshot week
      AND SHIP_YEAR = 2025 -- Orders shipping in 2025
    ```
2.  **Get 2025 Budget Value (Denominator):**
    ```sql
    SELECT SUM(NET_SALES) AS Budget_Value_Base_CY
    FROM lft.bronze.dds_frwshp_jedox
    WHERE REPORT_OPERATING_GROUP_DESC_UPDATED = 'Home And Accessories'
      AND YEAR = 2025 -- Matches OOH SHIP_YEAR
      AND SCENARIO = 'Budget'
      -- Add Standard Exclusions (Section 5.1) if applicable to Jedox context
      -- Ensure REPORT_OPERATING_GROUP_CODE_UPDATED is excluded if present in Jedox table
      -- Add other dimension filters if needed to match OOH query scope precisely
      ;
    ```
3.  **Calculate Fill Rate (Post-SQL):**
    *   `Fill Rate = (OOH_Value_Base_CY / Budget_Value_Base_CY) * 100` (Handle potential division by zero, Section 7.4).

#### 6.2.4. Example: Calculate 2024 OOH Fill Rate vs. 2024 Actuals for 'Home And Accessories' as of Week 15 (Snapshot taken in 2025)

*Compares prior year performance against Actuals, using a current snapshot week as the reference point for potentially still open historical orders (less common analysis, verify business need).*

1.  **Get 2024 OOH Value (Numerator):**
    ```sql
    -- Note: This query finds the value of orders scheduled for SY2024 that were *still active*
    -- in the Week 15 snapshot taken in 2025. This differs from the OOH *as of* 2024 Wk15.
    -- Confirm the business requirement carefully before using this pattern.
    SELECT CAST(SUM(OOH) AS DECIMAL(38, 10)) AS OOH_Value_Base_LY_Residual
    FROM fna.fna_bronze.vw_gob_spencerorderbook
    WHERE REPORT_OPERATING_GROUP_DESC_UPDATED = 'Home And Accessories'
      AND WEEK_NO = 15 -- Snapshot week (in 2025)
      AND SHIP_YEAR = 2024 -- Orders originally scheduled to ship in 2024
      -- Filtering by SHIP_YEAR=2024 targets the desired historical records.
    ```
    *Note: Interpretation of historical OOH viewed from a later snapshot needs careful consideration of business logic. Confirm what the comparison intends to measure.*
2.  **Get 2024 Actual Value (Denominator):**
    ```sql
    SELECT SUM(NET_SALES) AS Actual_Value_Base_LY
    FROM lft.bronze.dds_frwshp_jedox
    WHERE REPORT_OPERATING_GROUP_DESC_UPDATED = 'Home And Accessories'
      AND YEAR = 2024 -- Matches target historical Ship Year
      AND SCENARIO = 'Actual' -- Use 'Actual' for prior years
      -- Add Standard Exclusions (Section 5.1) if applicable
      -- Add other dimension filters if needed
      ;
    ```
3.  **Calculate Fill Rate (Post-SQL):**
    *   `Fill Rate = (OOH_Value_Base_LY_Residual / Actual_Value_Base_LY) * 100` (Handle division by zero, Section 7.4).

### 6.3. Comparing Year-over-Year (YoY) OOH

*Purpose: Compare OOH for the same snapshot week number but for different ship years.* **Requires SQL Aggregation (Section 6.6).**

#### 6.3.1. Example: Compare Wk 15 OOH for Ship Year 2025 vs. Ship Year 2024 for 'Home And Accessories'

*Assume the comparison point is Week 15 within the respective years.*

1.  **Get YoY_Difference (SY2025 Wk 15):**
*column **OOH** in the  `vw_gob_spencerorderbook` is Current_Year OOH amount, and we just need to apply filters to get the Curren_Year OOH amount in which week and which year. *
*column **LY_OOH** in the  `vw_gob_spencerorderbook` is Last_Year OOH amount, and we just need to apply filters to get the Last_Year OOH amount in which week and which year. *
*column **YoY_Difference** in the  `vw_gob_spencerorderbook` is YoY change, and we just need to apply filters to get the Last_Year OOH amount in which week and which year. *
    ```sql
    SELECT REPORT_CORPORATE_CUSTOMER_NAME, sum(YoY_Difference)
    FROM fna.fna_bronze.vw_gob_spencerorderbook
    WHERE REPORT_OPERATING_GROUP_DESC_UPDATED = 'Home And Accessories'
      AND WEEK_NO = 15
      GROUP BY REPORT_CORPORATE_CUSTOMER_NAME
      -- GROUP by REPORT_CORPORATE_CUSTOMER_NAME targets the sum of YoY_difference to the customer level. 
      ORDER BY sum(YoY_Difference) DESC
 -- ORDER by sum(YoY_Difference) DESC gives us the top increase customers. 
      LIMIT 10
 -- limit the top 10 customer with growth. 
    ```

3.  **Compare Results (Post-SQL):**
    *   Calculate YoY change: `Top Ten growth customers listed above`.
	* if asking for YoY decrease, change *ORDER By* to  `ORDER BY sum(YoY_Difference) AES`, and the results are top 10 decrease customers. 
	* Change the `select` clause by the users'ask, such as to `REPORT_OPERATING_GROUP_DESC_UPDATED`, or `REPORT_DIVISION_DESC`
*Purpose: Find which dimension members (e.g., Divisions, Customers) contributed most to the change between two periods.*


### 6.7 Lesson Learned: Performing YoY OOH Analysis with OG and Customer Drilldown

**Objective:** Analyze Year-over-Year (YoY) Order on Hand (OOH) changes for a specific week (e.g., comparing 2025 Wk15 vs 2024 Wk15), identifying key drivers at the Operating Group (OG) and Customer level. This integrates multiple concepts.

**Key Steps & Best Practices:**

1.  **Define Scope:** Target week (e.g., Wk15), Current Year (CY) Ship/Snapshot Year (e.g., 2025), Last Year (LY) Ship/Snapshot Year (e.g., 2024).
2.  **Data Source:** `fna.fna_bronze.vw_gob_spencerorderbook`.
3.  **SQL Aggregation (Critical - Section 6.6):** Use `SUM(OOH)` (cast to `DECIMAL(38, 10)`) and `GROUP BY` in SQL for *all* aggregations (Overall, OG-level, Customer-level). **Do not aggregate raw data client-side.**
4.  **Standard Filters (Section 5):** Apply consistent filters ( `WEEK_NO`, `SHIP_YEAR`) for YoY_Difference, WoW Difference. (Week Over Week Difference)
5.  **Overall & OG Level Analysis:**
    *   Query aggregated OOH totals (no `GROUP BY`) for CY and LY using identical filters.
    *   Query aggregated OOH totals `GROUP BY REPORT_OPERATING_GROUP_DESC_UPDATED` for CY and LY using identical filters.
    *   Calculate difference and YoY % change (handle division by zero - Section 7.4).
    *   Sort OGs by absolute difference.
7.  **Customer Level Drilldown (for Top Mover OGs):**
    *   Identify top 2-3 OGs with the largest absolute YoY change from Step 5.
    *   For each selected OG:
        *   Query aggregated OOH `GROUP BY REPORT_CORPORATE_CUSTOMER_NAME` for CY and LY, applying the same filters as Step 5 *plus* the specific `REPORT_OPERATING_GROUP_DESC_UPDATED` filter for that OG. **Refer to Appendix 8 for `REPORT_CORPORATE_CUSTOMER_NAME` warnings (high cardinality, potential truncation).**
        *   **Check Row Count:** Note the `.shape[0]` of the returned customer DataFrames (e.g., `df_cust_cy.shape[0]`). If near known tool limits (e.g., ~1000, see Section 7.6), truncation is possible.
        *   **Verification 2 (OG vs Customer Sum - Critical for High Cardinality):** Sum the retrieved customer-level aggregates for the OG (`df_cust_cy['OOH_Value_Base_CY'].sum()`) and compare against the verified OG total from Step 5/6. Repeat for LY. **This is crucial for detecting potential truncation of customer groups (Section 7.6, Manifestation 2).**
        *   Merge CY/LY customer data (`df_cust_merged = pd.merge(..., how='outer').fillna(0)`).
        *   Calculate absolute difference.
        *   Sort customers by absolute difference.
8.  **Reporting:**
    *   Structure: Overall Summary -> OG Performance -> Customer Drivers (for key OGs).
    *   **Crucially:** Explicitly state verification results (Step 6 & 7). If Verification 2 failed (Customer Sum != Verified OG Sum) or row counts strongly suggest truncation, clearly state that the customer-level analysis for that OG may be **incomplete** due to data retrieval limits (Section 7.6). Use cautious language (e.g., "Top identified customer contributors based on available data... Total change attributed to reported customers may not match OG total due to retrieval limits.").

## 7. Technical Tips & Troubleshooting

1.  **Check Query Output:** Immediately after fetching data (e.g., into a DataFrame `df`): check `df.head()`, `df.shape`, `df.columns`, `df.dtypes`. Ensure results are as expected and filters haven't excluded everything. Verify row counts (`df.shape[0]`) against expectations, especially for grouped queries (potential truncation, see Section 7.6).
2.  **SQL Aggregation & Verification:** If results seem incorrect, **first** re-verify your SQL query logic, filters, and **ensure you are using SQL aggregation** (`SUM()`/`GROUP BY`) as mandated in Section 6.6. **Second**, perform the total verification described in Section 6.6 Point 3. Failed verification often points to filter errors or retrieval limits (Section 7.6).
3.  **Data Type Conversion (Post-SQL):** Convert SQL types (Decimal, etc.) to standard Python types (`int`, `float`, `Decimal`) if needed for calculations, but do so carefully. Use Python's `Decimal` for high-precision arithmetic post-retrieval if required, as standard `float()` can lose precision.
    ```python
    # Example
    import decimal
    # Assuming df has 'Aggregated_Value' as object/Decimal type from SQL
    df['Aggregated_Value_Decimal'] = df['Aggregated_Value'].apply(decimal.Decimal)
    ```
4.  **Handle Division by Zero:** Use checks (`if divisor != 0 and divisor is not None:`) or safe methods (e.g., replace 0/NaN in denominator with `None` or a very small number if appropriate, or handle exceptions) before division when calculating ratios (YoY%, Fill Rate%).
5.  **Check Dictionary Keys / DataFrame Columns:** Avoid `KeyError` by double-checking names after operations like merging, pivoting, or renaming. Use `print(df.columns)` or `print(my_dict.keys())` for debugging.
6.  **Data Retrieval Tool Limits (e.g., `sql_read_enterprise`) (CRITICAL):**
    *   **Issue:** Tools used to execute SQL and retrieve results (like a hypothetical `sql_read_enterprise` function or similar connectors) may impose limits (e.g., an observed limit might be around 1000 rows/groups, but this can vary) on the data returned to the client environment (e.g., Python notebook).
    *   **Manifestation 1: Raw Data Truncation:** Fetching large, unaggregated datasets may return only a sample (e.g., the first N rows). **Never perform aggregations client-side on raw data retrieved this way if accurate totals are needed.** This is why Section 6.6 **mandates SQL aggregation** (`SUM`/`GROUP BY`) â€“ it avoids this problem entirely by performing the calculation correctly on the full dataset within the database *before* results are sent back.
    *   **Manifestation 2: Aggregated Group Truncation:** Even when using correct SQL aggregation (`SUM()`, `GROUP BY`), the tool might *still* truncate the result set if the number of *distinct groups* returned by the `GROUP BY` clause is large (e.g., > 1000 customers). The SQL aggregation itself runs correctly on the database across all data, but the client receives an incomplete list of the resulting groups/rows.
    *   **Impact:** Analyses based on grouped results might be **incomplete** if the number of groups exceeds the tool's limit. This is especially relevant for high-cardinality dimensions like `REPORT_CORPORATE_CUSTOMER_NAME` (Appendix 8). The totals derived from summing the *truncated* grouped results client-side will not match the true total.
    *   **Mitigation & Detection:**
        *   **Always use SQL aggregation (Section 6.6).** This avoids Manifestation 1.
        *   **Always perform total verification (Section 6.6 Point 3, Section 6.7 Step 6 & 7).** Comparing the sum of retrieved groups against a direct total query is the **primary method to detect Manifestation 2**.
        *   Check the number of rows returned (`df.shape[0]`) for grouped queries. If it's near a suspected limit (e.g., 1000), be highly suspicious of potential group truncation.
        *   **Acknowledge limitations:** If verification fails for high-cardinality grouped queries, report that the analysis is likely **incomplete** due to retrieval limits impacting the number of returned groups. Clearly state this limitation in findings.

## 8. Appendix: Known Working Dimensions for Breakdowns

*Note: 'Home & Accessories' and 'Apparel' OGs are sometimes called 'Supply Chain Services (SCS)' (Section 2.2).*

### 8.1. 'Home And Accessories' Operating Group (`REPORT_OPERATING_GROUP_DESC_UPDATED = 'Home And Accessories'`)

*   `REPORT_DIVISION_DESC`
*   `REPORT_CORPORATE_CUSTOMER_NAME`
    *   **Warning:** High Cardinality (many unique customer names).
    *   **Mandatory:** Use SQL Aggregation (`SUM`/`GROUP BY`) as per Section 6.6.
    *   **Risk:** Subject to potential **aggregated group truncation** by retrieval tools (e.g., ~1000 group limit, see Section 7.6, Manifestation 2) even with SQL aggregation.
    *   **Verification Required:** Always verify the sum of retrieved customer aggregates against the verified OG total (See Section 6.7, Step 7). Failure indicates truncation.
    *   **Reporting:** If verification fails or truncation is suspected (e.g., row count near limit AND verification fails), explicitly state that customer-level analysis for this OG is **incomplete** due to retrieval limits.

### 8.2. 'Apparel' Operating Group (`REPORT_OPERATING_GROUP_DESC_UPDATED = 'Apparel'`)

*   *(Add known working dimensions here as they are discovered)*
*   `REPORT_CORPORATE_CUSTOMER_NAME`
    *   **Warning:** High Cardinality (many unique customer names).
    *   **Mandatory:** Use SQL Aggregation (`SUM`/`GROUP BY`) as per Section 6.6.
    *   **Risk:** Subject to potential **aggregated group truncation** by retrieval tools (e.g., ~1000 group limit, see Section 7.6, Manifestation 2) even with SQL aggregation.
    *   **Verification Required:** Always verify the sum of retrieved customer aggregates against the verified OG total (See Section 6.7, Step 7). Failure indicates truncation.
    *   **Reporting:** If verification fails or truncation is suspected (e.g., row count near limit AND verification fails), explicitly state that customer-level analysis for this OG is **incomplete** due to retrieval limits.

*(Add more Operating Groups and their known working dimensions as they are discovered, applying similar warnings and verification requirements for high-cardinality dimensions.)*

#  Output Format: As mentioned at the beginning, your response should be formatted in html. If possible, please list them out as bullet points for easier reading. #

###  1.1 if you get PENDING in the ouput under state, status, example ,"status":{"state":"PENDING"}, try to run this query again for five time.

###  1.2. when you get the email question, plesae read **Subject**, for example **:</b> FW: 2025 Global Orderbook as of Jul 14** , this means they are asking number for the week of Jul 14, which is week no of 28. DO NOT USE Current Week No as mentioned in 5.1 above. 
